/*! \file TilfordReingold.h
 * \brief Tilford Reingold Tree Drawing Algorithm
 
 *  This file contains the functions required to implement the Tilford Reingold
 *  tree Drawing Algorithm using a created BST.
 */
#ifndef TILFORDREINGOLD_H
#define TILFORDREINGOLD_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "binaryTreeTR.h"

#define minsep 4 //!< Minimum Seperation

typedef struct extremepoints extr; //!< Structure to store extreme points of tree

//! Main Tilford Reingold Driver
/*! Extreme points for the rightmost and leftmost nodes 
 *  are allocated and passed in the call to
 *  ofset(...) for the post order traversal to generate
 *  relative positionnings
 *  followed by createPos(...) for the aboslute positioning
 *  through preorder 
 */
/*! \param root The root of the tree who's positioning is to be generated
 */
void generateTilfordReingold(node *root);


//! Relative Positioning of Nodes
/*!  Performs a post order traversal recursively along the left and
 *  right contours of the input tree
 */
/*! \param t The node whose left and right subtree's contours are to be followed
    \param level the height of the node passed
    \param rmost pointer which is to be set with the right most node in the subtree starting from given node
    \param lmost pointer which is to be set with the leftmost node in the subtree starting from given node
 */
void ofset(node *t,int level,extr *rmost,extr *lmost); //Helper Function for the TilfordReingold Routine

//! Absolute positioning of Nodes
/*! A recursive preorder travelsal to convert the relative positions
 *  generated by the first post order traversal
 *  into absolute positions
 *  The offset ( xPos) of a node is stored by it's parent and must be passed as a second attribute
 */
/*! \param t the node's whose absolute positioning is to be done
    \param xpos the aboslute position which is recursively passed down from the father
 */
void createPos(node *t,int xpos); // Creates final coordinates for each node

//! Structure to store extreme points of tree (one for left most and one for right most on each subtree)
struct extremepoints{
    node * addr; //!< A pointer to the node
    int off, //!< Offset of the ndoe withing the tree
        lev;//!< Height of the extreme point
};


void generateTilfordReingold(node *root){
    extr rightMost,leftMost;
    ofset(root,1,&rightMost,&leftMost);
    createPos(root,10);
}

void ofset(node *t,int level,extr *rmost,extr *lmost){/
    
    node *l //Left Son
    node *r;//Right Son
    extr lr,//right extreme of left subtree
        ll, //left extreme of left subtree
        rr, //right extreme of right subtree
        rl; //right extreme of right subtree
    
    int cursep;
    int rootsep,loffsum,roffsum;//offset from l & r to T
    
    if(t==NULL){ //avoid selecting an empty root as extreme
        lmost->lev=-1;
        rmost->lev=-1;
    }else{
        t->yPos=level;
        l=t->left; //follows contour of left subtree
        r=t->right;//follows contour of right subtree
        
        ofset(l,level+1,&lr,&ll);
        ofset(r,level+1,&rr,&rl);
        
        if (r==NULL&&l==NULL){//for leaf node
            
            rmost->addr=t;
            lmost->addr=t;
            rmost->lev=level;
            lmost->lev=level;
            rmost->off=0;
            lmost->off=0;
            t->offset=0;
            
        }else{
            //not a leaf nodes
            //consider eaach level in turn until one subtree is exhausted,pushing the subtree
            
            cursep=minsep;
            rootsep=minsep;
            loffsum=0;
            roffsum=0;
            while(l!=NULL&&r!=NULL){
                
                if(cursep<minsep){
                    //updating the distance of current seperation
                    rootsep=rootsep+(minsep-cursep);
                    cursep=minsep;
                }
                
                if(l->right!=NULL){
                    //Moving along left subtree
                    loffsum=loffsum+l->offset;
                    cursep=cursep-l->offset;
                    l=l->right;
                }else{
                    loffsum=loffsum-l->offset;
                    cursep=cursep+l->offset;
                    l=l->left;
                }
                
                if(r->left!=NULL){
                    //Moving along right subtree
                    roffsum=roffsum-r->offset;
                    cursep=cursep-r->offset;
                    r=r->left;
                }else{
                    roffsum=roffsum+r->offset;
                    cursep=cursep+r->offset;
                    r=r->right;
                }
            }
            
            //accumulated offset for Left tree and Right tree
            t->offset=(rootsep+1)/2;
            loffsum-=t->offset;
            roffsum+=t->offset;
            
            //updating the local extreme points
            if(rl.lev>ll.lev||t->left==NULL){
                *lmost=rl;
                lmost->off+=t->offset;
            }else{
                *lmost=ll;
                lmost->off-=t->offset;
            }
            
            if(lr.lev>rr.lev||t->right==NULL){
                *rmost=lr;
                rmost->off+=t->offset;
            }else{
                *rmost=rr;
                rmost->off-=t->offset;
            }
            
            /*! Threading is done if the left and right
             *  subtrees are of differing heights
             */
            if(l!=NULL&&l!=t->left){
                (rr.addr)->thread=1;
                (rr.addr)->offset=abs(rr.off+t->offset-loffsum);
                if(loffsum-t->offset<=rr.off){
                    (rr.addr)->left=l;
                }else{
                    (rr.addr)->right=l;
                }
            }else if(r!=NULL&&r!=t->right){
                (ll.addr)->thread=1;
                (ll.addr)->offset=abs(ll.off+t->offset-roffsum);
                if(roffsum-t->offset>=ll.off){
                    (ll.addr)->right=r;
                }else{
                    (ll.addr)->left=r;
                }
            }
        }
    }
}


//creating position and removing all the threads created

void createPos(node *t,int xpos){
    if (t!=NULL){
        t->xPos=xpos;
        if(t->thread==1){
            t->thread=0;
            t->left=NULL;
            t->right=NULL;
        }
        createPos(t->left,xpos-t->offset);
        createPos(t->right,xpos+t->offset);
    }
}


#endif

