/*! \file WetherellShannon.h
 * \brief Wetherell Shannon Tree Drawing Algorithm
 
 *  This file contains the functions required to implement the Wetherell Shannon
 *  tree Drawing Algorithm. There is support for both the normal version through
 *  the NORMAL AlgorithmType as well as the narrower version which provides minimum
 *  width without ensuring that parents are centered over their children through the
 *  MODIFIED AlgorithmType enumeration
 */

#ifndef WETHERELLSHANNON_H

/*! \breif Header Guard to Prevent Redeclaration
*/
#define WETHERELLSHANNON_H
#include<stdio.h>
#include<stdlib.h>
#include<string.h>

//! Enumeration to specify type of secondpass of Wetherell Shannon
/*!
*   Implementation that supports normal and modified (narrower) version of algorithm
*/
enum AlgorithmType{
    NORMAL,  /*!< For pretty trees that may not conform to width */
    MODIFIED /*!< Narrower trees which may not have children centered ovr parent */
             };



//! Main Wetherell Shannon Loop
/*! Performs a Preorder Walk of the given tree and generated a provisional 'place' for
    each node. Also stores the distance to each provisional place within the modifier
    field.
 * Provisional place is assigned according to the nature of the node :
 * 1. Leaf : Place at next avaiable x
 * 2. Has Left son, place to its right
 * 3. Has Right Sons, place to its left
 * 4. Has Both sons, place at average
 */
/*! \param root The root of the tree who's nodes to position
 \param treeHeight The height of the given tree
 \param secondPass Enumeration which specifies whether to use narrower version
 */
int generateWetherellShannon(node *root,int treeHeight,enum AlgorithmType secondPass);


//! Normal Second While loop of Wetherell Shannon
/*!
 *  Performs pre order walk and in the process:
 *  Cummulates modifier values of nodes at each level, generated by the first pass
    and bodily shifts nodes accordingly (to the left) at each level
 */
/*! \param root The root of the tree to perform second pass over
 */
void SecondPass(node *root);



//! Modified Second While loop of Wetherell Shannon for the narrower implementation
/*!
 *  Peforms a pre order walk and in the process :
 *  Maintains Minimum width while violating center over children (Aesthetic 3) and
 *  Maintains actual next position of each node and decides x-position as a minimum of three
    values :
 *  1. Next Position Avaliable in nextPos at the level
 *  2. Left Child's Position -1 (Left of child)
 *  3. Father's Position +1 (right of father)
 */
/*! \param root The root of the tree to perform second pass over
 \param maxHeight The height of the given tree
 */
void SecondPassModified(node *root,int maxHeight);



//! Checks whether given node is a leaf (no chilren)
/*! \param NODE the node to check
 \return 1 if it is a leaf 0 otherwise
 */
int isleaf(node *NODE);



//! Returns minimum of two numbers
int minimum(int a, int b);

//! Return maximum of two numbers
int maximum(int a, int b);



int generateWetherellShannon(node *root,int treeHeight,enum AlgorithmType secondPass){
    
    /*! <b> modifier </b> An array of size of tree height used to save shift requirements at each level as walk progresses.
     * Initialised to all zeros
     */
    int modifier[treeHeight+1];
    /*! <b> nextPos </b>  An array of size of tree height used to store next available position at each level taking into account  modifiers encountered so far.
     *  Initialized to all ones.
     */
    int nextPos[treeHeight+1];
    int counter;
    int place;
    int height;
    int isLeaf=0;
    node *current;
    
    for(counter=0;counter<=treeHeight;counter++){
        nextPos[counter]=1;
        modifier[counter]=0;
    }
    current=root;
    current->status=FIRST_VISIT;
    
    //Begin Pre Order Walk
    while(current != NULL){
        
        switch(current->status){
            case FIRST_VISIT:
                current->status=LEFT_VISIT;
                if(current->left !=NULL){
                    current=current->left;
                    current->status=FIRST_VISIT;
                }
                break;
                
            case LEFT_VISIT:
                current->status=RIGHT_VISIT;
                if(current->right !=NULL){
                    current=current->right;
                    current->status=FIRST_VISIT;
                }
                break;
                
            case RIGHT_VISIT:
                height=current->nodeheight;
                isLeaf=isleaf(current);
                if(isLeaf)
                    place=nextPos[height];
                else if (current->left==NULL)
                    place=( (current->right)->xPos ) - 1;
                else if (current->right==NULL)
                    place=( (current->left)->xPos ) + 1;
                else
                    place=( (current->left)->xPos + (current->right)->xPos)/2;
                
                modifier[height]=maximum(modifier[height],nextPos[height]-place);
                
                if(isLeaf)
                    current->xPos=place;
                else
                    current->xPos=place +modifier[height];
                
                nextPos[height]=current->xPos+2;
                current->modifier=modifier[height];
                current=current->father;
                
                break;
        }
    }

    if(secondPass==NORMAL)
        SecondPass(root);
    else
        SecondPassModified(root,maxHeight);
    return 1;
}

void SecondPass(node *root){
    
    node *current=root;
    current->status=FIRST_VISIT;
    int modifierSum=0;
    while(current !=NULL){
        
        switch(current->status){
            case FIRST_VISIT:
                current->xPos=current->xPos+modifierSum;
                modifierSum=modifierSum + current->modifier;
                current->yPos=2*current->nodeheight+1;
                current->status=LEFT_VISIT;
                if(current->left !=NULL){
                    current=current->left;
                    current->status=FIRST_VISIT;
                }
                break;
            case LEFT_VISIT:
                current->status=RIGHT_VISIT;
                if(current->right!=NULL){
                    current=current->right;
                    current->status=FIRST_VISIT;
                }
                break;
            case RIGHT_VISIT:
                modifierSum= modifierSum - current->modifier;
                current=current->father;
                break;
        }
        
    }
    
}

void SecondPassModified(node *root,int maxHeight){

  node *current=root;
  current->status=FIRST_VISIT;
  int modifierSum=0;
  int nextPos[maxHeight+1];

  int counter=0;
  for(counter=0;counter<=maxHeight;counter++)
    nextPos[counter]=1;

  while(current !=NULL){

    switch(current->status){
      case FIRST_VISIT:
                        modifierSum=modifierSum + current->modifier;
                        current->status=LEFT_VISIT;
                        if(current->left !=NULL){
                          current=current->left;
                          current->status=FIRST_VISIT;
                        }
                        break;
      case LEFT_VISIT:
                      current->xPos=minimum(nextPos[current->nodeheight], current->xPos + modifierSum - current->modifier);
                      if(current->left !=NULL)
                        current->xPos=maximum(current->xPos,current->left->xPos + 1);

                      if(current->father!=NULL){
                        if(current->father->status == RIGHT_VISIT)
                          current->xPos=maximum(current->xPos,current->father->xPos +1);
                      }

                      nextPos[current->nodeheight]=current->xPos +2;
                      current->yPos=2*current->nodeheight + 1;
                      current->status=RIGHT_VISIT;
                      if(current->right!=NULL){
                        current=current->right;
                        current->status=FIRST_VISIT;
                      }
                      break;
      case RIGHT_VISIT:
                        modifierSum= modifierSum - current->modifier;
                        current=current->father;
                        break;
    }

  }

}

int isleaf(node *NODE){
  if ((NODE->left == NULL) && (NODE->right == NULL))
      return 1;
}

int maximum(int a,int b){
  if(a>b)
    return a;
  else
    return b;
}
int minimum(int a, int b){
  if(a>b)
    return b;
  else
    return a;
}

#endif
