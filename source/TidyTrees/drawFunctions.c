#ifndef DRAWFUNCTIONS_H
#define DRAWFUNCTIONS_H
/* Contains all functions used to transalte the coordinates generated by the 
 drawing algorithms to an on-screen represenatation. We use OpenGL for drawing
 and GLUT for windowing*/


#include<stdio.h>
#include<GLUT/glut.h>
#include<math.h>

/* Draws a line from (x0,y0) to (x1,y1) in 
 accordance with the Bresenham Midpoint Line Algorithm */
void BresenhamLine(int x0,int y0,int x1,int y1);

/*Draws a circle with given radius and 
 center using the midpoint algorithm */
void MidPointCircle(int xc,int yc,int radius);

/* Exploits 8-Way symmetry of the circle */
void CirclePoints(int xc,int yc,int x,int y);

void PutPixel(int x,int y); // Draws a point at (x,y) on the screen

int sign(int x);// Returns 1 if x is positive and -1 otherwise

/* 8 Neighbour Flood fill algorithm to fill circle 
 of given radius and center */
void fill(int x,int y,int xc,int yc, int radius);

char visited[50][50];// Used in conjunction with fill algorithm above

void BresenhamLine(int x0,int y0,int x1,int y1){


    int i;
    int x=x0;
    int y=y0;
    
    int dx=abs(x1-x0);
    int dy=abs(y1-y0);
    
    int sign1=sign(x1-x0);
    int sign2=sign(y1-y0);
    
    int swapFlag=0; // Indicated whether initial values of x and y have been swapped
    
    if(dy>dx){ // If |Slope| > 1 , draw one  pixel per row
        int temp=dx;
        dx=dy;
        dy=temp;
        swapFlag=1;
    }
    
    int decision=2*dy -dx; // Decision variable to decide updates
    
    for(i=0;i<dx;i++){ // Draw as many pixels as rows or columns (if swapFlag==1)
        
        PutPixel(x,y);
        while(decision>=0){
            decision-= 2*dx;
            
            if(swapFlag)
                x+=sign1;
            else
                y+=sign2;
            
        }
        decision+=2*dy;
        
        if(swapFlag)
            y+=sign2;
        else
            x+=sign1;
    }
    
}

void MidPointCircle(int xc,int yc,int radius){

    int x=0;
    int y=radius;
    
    int d=1-radius; //Decision Variable
    
    //Second Order Differences
    int deltaE= 3;
    int deltaSE= -2*radius +5;
    
    CirclePoints(xc,yc,x,y);
    
    while(y>x)
    {
        if(d<0)//Choose East Pixel
        {
            d+=deltaE;
            deltaE+=2;
            deltaSE+=2;
        }
        else//Choose South-East Pixel
        {
            d+=deltaSE;
            deltaE+=2;
            deltaSE+=4;
            y--;
        }
        x++;
        //Draw Two circles to obtain a thick boundary
        CirclePoints(xc,yc,x,y);
        CirclePoints(xc,yc,x+1,y+1);
    }
    
    
}



void CirclePoints(int xc,int yc,int x,int y){ // 8-Way Circle Symmetry
    PutPixel(xc+x,yc+y);
    PutPixel(xc+y,yc+x);
    PutPixel(xc+y,yc-x);
    PutPixel(xc+x,yc-y);
    PutPixel(xc-x,yc-y);
    PutPixel(xc-y,yc-x);
    PutPixel(xc-y,yc+x);
    PutPixel(xc-x,yc+y);
}

void PutPixel(int x, int y){

    glBegin(GL_POINTS);
    glVertex2i(x,y);
    glEnd();
    
    glFlush(); //Flush the buffer to draw to screen
    
}

void fill(int x,int y,int xc,int yc,int radius){
    int dec=(x-xc)*(x-xc) +(y-yc)*(y-yc);
    
    if(dec < (radius*radius) && visited[radius+(x-xc)][radius+(y-yc)]==0){ //Draw and call 4 neighbours if current is inside given circle
        PutPixel(x,y);
        
        visited[radius+(x-xc)][radius+(y-yc)]=1;// Update matrix so fill does not fill it again later.
        
        fill(x,y-1,xc,yc,radius);
        fill(x,y+1,xc,yc,radius);
        fill(x+1,y,xc,yc,radius);
        fill(x-1,y,xc,yc,radius);
    }
}
//Return +1 if positive -1 if negative and 0 if 0
int sign(int x){
    if(x>0)
        return 1;
    else if(x<0)
        return -1;
    else
        return 0;
}
#endif

